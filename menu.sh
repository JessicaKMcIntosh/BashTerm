#!/usr/bin/env bash
# shellcheck disable=SC2034 # Some variables may remain unused in this file.
# shellcheck source=attr.sh
# shellcheck source=boxes.sh
# shellcheck source=color.sh
# shellcheck source=cursor.sh
# shellcheck source=function.sh

# BashTerm by Jessica K McIntosh is marked CC0 1.0.
# To view a copy of this mark, visit:
# https://creativecommons.org/publicdomain/zero/1.0/

# A library for making menus.

# DO NOT EDIT THIS FILE!
# Edit the files in src/ then run the make.sh script.

# This requires bash version 4.
if ((BASH_VERSINFO[0] < 4)); then
    echo "This script requires Bash 4 or later."
    echo "Current version: ${BASH_VERSION}"
    exit 1
fi

# Only load the library once.
declare -A _TERM_LOADED # Track loaded files.
declare _TERM_FILE_NAME="${BASH_SOURCE[0]##*/}"
if [[ -v _TERM_LOADED[${_TERM_FILE_NAME}] ]]; then
    [[ -v TERM_VERBOSE ]] && echo "Already loaded '${_TERM_FILE_NAME}'."
    return 0
fi
_TERM_LOADED[${_TERM_FILE_NAME}]="${BASH_SOURCE[0]}"
[[ -v TERM_VERBOSE ]] && echo "Loading '${_TERM_FILE_NAME}'..."
unset _TERM_FILE_NAME

# Load the libraries.
declare -a library_list=("attr.sh")
find_library() {
    local library="${1}"
    local file_name
    for file_name in {../,./}${library}; do
        if [[ -f ${file_name} ]]; then
            echo "${file_name}"
            exit
        fi
    done
    echo "Unable to locate the library '${library}'." >&2
    exit 1
}
#TERM_VERBOSE=0 # Uncomment for verbose library loading.
declare _TERM_LOAD_LIBRARY
for _TERM_LOAD_LIBRARY in "${library_list[@]}"; do
    source "$(find_library "${_TERM_LOAD_LIBRARY}")" || exit 1
done
unset _TERM_LOAD_LIBRARY

# Default settings.
declare _TERM_MENU_SEPARATOR=":"
declare _TERM_MENU_PROMPT="Select the option [~]: "

term::menu() {
    if (($# < 3)); then
        echo "MENU ERROR: Insufficient parameters passed!" >&2
        exit 252
    fi
    local title="${1}"
    local options="${2}"
    shift 2
    local menu_items=("$@")

    # Internal variables.
    local item              # Current array element or option being processed.
    local key               # The pressed key, also used for building the menu.
    local rc                # Return code.
    local text              # Text for the menu or an error message.
    local valid_keys=""     # The list of valid keys.
    local -a menu_list      # The rendered menu list to print.
    local -A key_list       # Translate key to return code.
    local -A option_list    # The various options set for the menu.

    # Setup the options.
    option_list[sep]="${_TERM_MENU_SEPARATOR}"
    option_list[prompt]="${_TERM_MENU_PROMPT}"
    option_list[attr]="" # Attributes for the key character in the menu.
    while IFS="" read -r item; do
        [[ -z ${item} ]] && continue
        case "${item}" in
            sep*)       option_list[sep]="${item:3}" ;;
            prompt*)    option_list[prompt]="${item:6}" ;;
            bold)       option_list[attr]+="${TERM_BOLD}" ;;
            reverse)    option_list[attr]+="${TERM_REVERSE}" ;;
            underline)  option_list[attr]+="${TERM_UNDERLINE}" ;;
            *)          option_list[${item}]="${item}" ;;
        esac
    done <<< "${options//|/$'\n'}"

    # Build the menu.
    for item in "${!menu_items[@]}"; do
        # Empty string is a special case.
        if [[ -z ${menu_items[$item]} ]]; then
            menu_list+=("")
            continue
        fi

        # Check for parameters to the menu item.
        IFS="|" read -r key rc text <<< "${menu_items[$item]}"
        if [[ -z ${rc} && -z ${text} ]]; then
            # No parameters so use the defaults.
            key="$((item + 1))"
            rc="$((item + 1))"
            text="${menu_items[$item]}"
        else
            # Check for empty parameters.
            if [[ -z ${rc} ]]; then
                rc="$((item + 1))"
            fi
            if [[ -z ${key} ]]; then
                key="$((item + 1))"
            fi
        fi

        # Check that the return code is a number in range.
        if [[ ${rc} != "~" && (${rc} -gt "250" || "$((rc + 0))" != "${rc}") ]]; then
            echo "MENU ERROR: Return code (${rc}) invalid! Must be a number 250 or less." >&2
            echo "Menu item: ${menu_items[$item]}"
            return 254
        fi

        # Check that the key is one character.
        if [[ ${#key} -gt "1" ]]; then
            echo "MENU ERROR: Key (${key}) is not a single character." >&2
            echo "Menu item: ${menu_items[$item]}"
            return 253
        fi

        # Save the menu item.
        if [[ ${key} == "~" ]]; then
            if [[ ${text} != "~" ]]; then
                # No key, just the text.
                menu_list+=("${text}")
            fi
        else
            if [[ ${rc} != "~" ]]; then
                # Save the key and return code.
                key_list[$key]=$rc
            fi
            if [[ ${text} != "~" ]]; then
                # There is text to print so save the menu item.
                valid_keys+="${key}"
                if [[ -v option_list[attr] ]]; then
                    key="${option_list[attr]}${key}${TERM_RESET}"
                fi
                menu_list+=("${key}${option_list[sep]} ${text}")
            fi
        fi
    done

    # Debug data.
    if [[ -v option_list[debug] ]]; then
        echo -n "DEBUG (Options): " >&2
        declare -p option_list >&2
        echo -n "DEBUG (Menu List): " >&2
        declare -p menu_list >&2
        echo -n "DEBUG (Key RC List): " >&2
        declare -p key_list >&2
        read -rsn1 -p "Press any key to continue..." >&2
    fi

    # Menu loop.
    text=""
    while true; do
        # Print the menu.
        if [[ -v option_list[clear] ]]; then
            echo -n "${TERM_CLEAR}"
        fi
        echo "${title}"
        for item in "${menu_list[@]}"; do
            echo "$item"
        done

        # Print the error text if present and quiet is not set.
        if [[ -n ${text} && ! (-v option_list[quiet]) ]]; then
            echo "ERROR: ${text}"
        fi

        # Handle user input.
        read -r -n 1 -p "${option_list[prompt]/\~/${valid_keys}}"
        echo ""
        if [[ -v key_list[${REPLY}] ]]; then
            return "${key_list["${REPLY}"]}"
        else
            if [[ -n ${REPLY} ]]; then
                echo ""
                text="Invalid option ($REPLY)."
            else
                text="Please select a key."
            fi
            if [[ -v option_list[one] ]]; then
                if [[ ! (-v option_list[quiet]) ]]; then
                    echo "${text}"
                fi
                return 251
            fi
        fi
    done
}

# Print some help text.
term::menu_usage() {
    # Print any messages passed in.
    if (($# > 0)); then
        while (($# > 0)); do
            echo "$1"
            shift
        done
        echo ""
    fi

    echo "Usage: $0 TITLE OPTIONS [MENU_LIST]"
    echo ""
    echo "Displays a menu with the given options."
    echo "See the file doc/menu.md' for usage."
    echo ""
    echo "Options:"
    echo "    -h        This text."
    echo ""
    echo "Example:"
    echo '# ./menu.sh "Test Menu" "" "Error?" "0|0|Exit"'
    echo ""
    echo "Output:"
    echo 'Test Menu'
    echo '1: Error?'
    echo '0: Exit'
    echo 'Select the option [10]:'
    exit 1
}

# Act like a useful script.
term::menu_main() {
    local option

    # Check command line args.
    while getopts ":h" option; do
        case $option in
            h)  term::menu_usage ;;
            *)  if [ "${OPTARG}" = "-" ]; then
                    term::menu_usage # They probably only want help. Catches --help.
            else
                    term::menu_usage "Invalid option '${OPTARG}'." # Illegal option.
            fi    ;;
        esac
    done
    shift $((OPTIND - 1))

    # Print the message.
    if (($# > 0)); then
        term::menu "${@}"
    fi
}

# If called directly then run menu or reference the example.
if [[ ${0} == "${BASH_SOURCE[0]}" ]]; then
    if (($# == 0)); then
        declare example_file="${0##*/}"
        example_file="${example_file%.*}"
        echo "For an example try:"
        printf "./examples/%s_example.sh\n" "${example_file}"
        echo ""
        echo "For help:"
        echo "${0} -h"
    else
        # term::menu "${@}"
        term::menu_main "${@}"
    fi
fi
