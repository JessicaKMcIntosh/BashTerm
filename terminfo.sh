#!/usr/bin/env bash

# BashTerm by Jessica K McIntosh is marked CC0 1.0.
# To view a copy of this mark, visit:
# https://creativecommons.org/publicdomain/zero/1.0/

# A direct interface to the terminfo description.

# DO NOT EDIT THIS FILE!
# Edit the files in src/ then run the make.sh script.

# This requires bash version 4.4 or later.
if [ -z "$BASH_VERSION" ]; then
    echo "Error: Bash version 4.4 or higher is required."
    exit 1
fi
if ((BASH_VERSINFO[0] < 4)) || ((BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4)); then
    echo "Error: Bash version 4.4 or higher is required."
    echo "Current version: ${BASH_VERSION}"
    exit 1
fi

# Only load the library once.
declare -A _TERM_LOADED # Track loaded files.
declare _TERM_FILE_NAME="${BASH_SOURCE[0]##*/}"
if [[ -v _TERM_LOADED[${_TERM_FILE_NAME}] ]]; then
    [[ -v TERM_VERBOSE ]] && echo "Already loaded '${_TERM_FILE_NAME}'."
    return 0
fi
_TERM_LOADED[${_TERM_FILE_NAME}]="${BASH_SOURCE[0]}"
[[ -v TERM_VERBOSE ]] && echo "Loading '${_TERM_FILE_NAME}'..."
unset _TERM_FILE_NAME

# Contains the terminfo details.
declare -A TERM_INFO

# Static variable storage file.
declare -g _TERM_INFO_VARIABLE_FILE=""

# Read the terminfo description
term::info_init() {
    local name value term_name

    # Make sure infocmp is installed.
    if ! command -v infocmp > /dev/null; then
        echo "The required command 'infocmp' is not installed."
        exit 1
    fi

    # Read the capabilities and store them into TERM_INFO.
    while IFS='=' read -r name value; do
        # Strip the trailing comma.
        # Without this comma read will drop a trailing '='.
        value=${value%,}
        TERM_INFO[${name}]=${value}
    done < <(infocmp -q -1 -l | awk -f setupterm.awk)

    # Create the storage for static variables.
    trap '[[ -n $_TERM_INFO_VARIABLE_FILE ]] && rm -f "${_TERM_INFO_VARIABLE_FILE}"' EXIT
    _TERM_INFO_VARIABLE_FILE=$(mktemp --tmpdir BashTermInfoVars.XXXXXXXXXX) || exit
}
term::info_init

# Print the interpreted value for a terminal capability.
term::info_tput() {
    local name=${1:-}
    shift
    local -a parameters=("${@}")
    local value

    if [[ -v TERM_INFO[${name}] ]]; then
        value=${TERM_INFO[${name}]}
    else
        echo "Invalid capability name ${name@Q}."
        return 1
    fi

    # Easy case, no parameters.
    if [[ ! "${value/%}" =~ [%] ]]; then
        printf "${value}"
        return 0
    fi

    # Parameters are required. Run it through awk.
    #printf "$(gawk --lint -vvar_file="${_TERM_INFO_VARIABLE_FILE}" -f tparm.awk -- "${value}" "${parameters[@]}")"
    printf "$(gawk -vvar_file="${_TERM_INFO_VARIABLE_FILE}" -f tparm.awk -- "${value}" "${parameters[@]}")"
    # gawk -D --lint -f tparm.awk -- "${value}" "${parameters[@]}"
    #gawk -vvar_file="${_TERM_INFO_VARIABLE_FILE}" -f tparm.awk -- "${value}" "${parameters[@]}"
}


term::info_test() {
    local name value my_output tput_output tput_return
    # declare -p test_list

    while IFS=$'=' read -r name value; do
        # Strip the trailing comma.
        # Without this comma read will drop a trailing '='.
        value=${value%,}
        my_output="$(term::info_tput "${name}" 1 2 3 4 5 6 7 8 9)"
        if [[ ${name} == "clear" ]]; then
            # tput does strange things for 'clear'. :(
            tput_output="$(tput -x "${name}" | tr -d '\000')"
        else
            tput_output="$(tput "${name}" 1 2 3 4 5 6 7 8 9 2>/dev/null | tr -d '\000')"
            tput_return=$?
            if [[ ! $tput_return ]] ; then
                echo "Error running 'tput ${name} 1 2 3 4 5 6 7 8 9'. Return Code: $tput_return" 1>&2
                exit 1
            fi
        fi
        if [[ ${my_output} != "${tput_output}" ]]; then
            echo "Capability ${name}=(${value}) does not match..."
            printf "Expected: "
            printf "${tput_output}" | xxd
            printf "Actual  : "
            printf "${my_output}" | xxd
        fi
    done < <(infocmp -q -1 -l | sed -n -e 's/^\t//;/=.*$/p')

}

# declare -p TERM_INFO

# echo ""
# printf "This is "
# term::info_tput "smul"
# printf "Underlined"
# term::info_tput "sgr0"
# printf ".\n"

# term::info_tput "rep" "1" "2"
# term::info_tput "rep" "2" "3" | xxd
# tput rep 2 3 | xxd

# term::info_tput "setf" "0" | xxd
# tput setf 0 | xxd
# for number in {0..9}; do
    # echo "# ${number}"
    # term::info_tput "setf" ${number} | xxd
    # tput setf ${number} | xxd
# done
# term::info_tput "cup" "1" "2" | xxd
# tput cup 1 2 | xxd

echo "Running tests..."
echo "Terminal: ${TERM_INFO[_name]} : ${TERM_INFO[_descr]}"
term::info_test
echo "Done."
echo ""

echo "Variables (${_TERM_INFO_VARIABLE_FILE}):"
cat "${_TERM_INFO_VARIABLE_FILE}"
