#!/usr/bin/env bash

# BashTerm by Jessica K McIntosh is marked CC0 1.0.
# To view a copy of this mark, visit:
# https://creativecommons.org/publicdomain/zero/1.0/

# A direct interface to the terminfo description.

# DO NOT EDIT THIS FILE!
# Edit the files in src/ then run the make.sh script.

# This requires bash version 4.4 or later.
if [ -z "$BASH_VERSION" ]; then
    echo "Error: Bash version 4.4 or higher is required."
    exit 1
fi
if ((BASH_VERSINFO[0] < 4)) || ((BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4)); then
    echo "Error: Bash version 4.4 or higher is required."
    echo "Current version: ${BASH_VERSION}"
    exit 1
fi

# Only load the library once.
declare -A _TERM_LOADED # Track loaded files.
declare _TERM_FILE_NAME="${BASH_SOURCE[0]##*/}"
if [[ -v _TERM_LOADED[${_TERM_FILE_NAME}] ]]; then
    [[ -v TERM_VERBOSE ]] && echo "Already loaded '${_TERM_FILE_NAME}'."
    return 0
fi
_TERM_LOADED[${_TERM_FILE_NAME}]="${BASH_SOURCE[0]}"
[[ -v TERM_VERBOSE ]] && echo "Loading '${_TERM_FILE_NAME}'..."
unset _TERM_FILE_NAME

# Contains the terminfo details.
declare -A TERM_INFO

# Read the terminfo description
term::info_init() {
    local name value term_name

    # Make sure infocmp is installed.
    if ! command -v infocmp > /dev/null; then
        echo "The required command 'infocmp' is not installed."
        exit 1
    fi

    # Read the capabilities and store them into TERM_INFO.
    while IFS=$'=' read -r name value; do
        # The first line is the terminal name and description.
        if [[ -z ${term_name} ]]; then
            IFS='|' read -r name value < <(echo "${name}")
            term_name=${name}
            TERM_INFO[_name]=${name}
            TERM_INFO[_descr]=${value}
            continue
        fi
        # [[ -z ${value} ]] && value=${name}
        # printf ">>%s<< >>%s<<\n" "${name@Q}" "${value@Q}"
        TERM_INFO[${name}]=${value}
    done < <(
        infocmp -q -1 -l |
        awk -f parse_info.awk
    )
}
term::info_init

# Print the interpreted value for a terminal capability.
term::info_print() {
    local name=${1:-}
    shift
    local -a parameters=("${@}")
    local value

    if [[ -v TERM_INFO[${name}] ]]; then
        value=${TERM_INFO[${name}]}
    else
        echo "Invalid capability name ${name@Q}."
        return 1
    fi

    # Easy case, no parameters.
    if [[ ! "${value/%}" =~ [%] ]]; then
        printf "${value}"
        return 0
    fi

    # echo "PARAMETERIZED!! >>${name}<< >>${value}<< >>${parameters[*]}<<"
    # printf "$(gawk --lint -f print_info.awk -- "${value}" "${parameters[@]}")"
    printf "$(gawk -f print_info.awk -- "${value}" "${parameters[@]}")"
    # gawk -D --lint -f print_info.awk -- "${value}" "${parameters[@]}"
}

declare -p TERM_INFO

# echo ""
# printf "This is "
# term::info_print "smul"
# printf "Underlined"
# term::info_print "sgr0"
# printf ".\n"

# term::info_print "rep" "1" "2"
# term::info_print "rep" "2" "3" | xxd
# tput rep 2 3 | xxd

# term::info_print "setf" "0" | xxd
# tput setf 0 | xxd
for number in {0..9}; do
    echo "# ${number}"
    term::info_print "setf" ${number} | xxd
    tput setf ${number} | xxd
done

# term::info_print "cup" "1" "2" | xxd
# tput cup 1 2 | xxd



# term::info_print "clear" #| xxd
# printf "${TERM_INFO[cub1]}"
# echo ""
# printf "${TERM_INFO[cub1]}" | xxd
# echo ""

# awk '
#     BEGIN {
#         string="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
#         for (i=1; i <= length(string); i++) {
#             character = substr(string, i, 1)
#             printf "%s = %03d\n", character, index("ABCDEFG  HIJKLMNO  PQRSTUVW  XYZ", toupper(character))
#         }
#     }
# '
